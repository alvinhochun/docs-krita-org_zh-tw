# SOME DESCRIPTIVE TITLE.
# Copyright (C) licensed under the GNU Free Documentation License 1.3+ unless stated otherwise
# This file is distributed under the same license as the Krita Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Krita Manual 5.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-27 21:21+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../untranslatable_pages/strokes_documentation.rst:1
msgid "Strokes documentation"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:13
msgid "Strokes queue"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:16
msgid "Strokes, jobsâ€¦ What it is all about? (theory)"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:19
msgid "Structure of a stroke"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:21
msgid "An abstraction of a *stroke* represents a complete action performed by a user. This action can be canceled when it has not been finished yet, or can be undone after it's undo data has been added to the undo stack. Every stroke consists of a set of *stroke jobs*. Every job sits in a queue and does a part of work that the stroke as a whole must perform on an image. A stroke job cannot be canceled while execution and you cannot undo a single job of the stroke without canceling the whole stroke."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:29
msgid "**Example:** Lets look at how the Freehand Tool works. Every time the user paints a single line on a canvas it creates a *stroke*. This stroke consists of several *stroke jobs*: one job initializes indirect painting device and starts a transaction, several jobs paint dabs of a canvas and the last job merges indirect painting device into the canvas and commit the undo information."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:36
msgid "The jobs of the stroke can demand special order of their execution. That is the way how they will be executed on a multi-core machine. Every job can be either of the type:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:46
msgid "``CONCURRENT``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:41
msgid "*concurrent* job may be executed in parallel with any other concurrent job of the stroke as well as with any update job executed by the scheduler"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:45
msgid "**Example:** in Scale Image action each job scales its own layer. All the jobs are executed in parallel."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:59
msgid "``SEQUENTIAL``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:49
msgid "if the job is *sequential*, no other job may interleave with this one. It means that when the scheduler encounters a sequential job, it waits until all the other stroke jobs are done, starts the sequential job and will not start any other job until this job is finished. Note that a sequential job can be executed in parallel with update jobs those merge layers and masks."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:56
msgid "**Example:** All the jobs of the Freehand Tool are sequential because you cannot rearrange the painting of dabs. And more than that, you cannot mix the creation of the transaction with painting of anything on a canvas."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:76
msgid "``BARRIER``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:62
msgid "*barrier* jobs are special. They created to allow stroke jobs to synchronize with updates when needed. A barrier job works like a sequential one: it does not allow two stroke jobs to be executed simultaneously, but it has one significant addition. A barrier job will not start its execution until *all* the updates (those were requested with ``setDirty()`` calls before) has finished their execution. Such behavior is really useful for the case when you need to perform some action after the changes you requested in previous jobs are done and the projection of the image does now correspond the changes you've just done."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:73
msgid "**Example:** in Scale Image action the signals of the image like ``sigSizeChanged`` should be emitted after all the work is done and all the updates are finished. So it runs as a barrier job. See ``KisProcessingApplicator`` class for details."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:78
msgid "Besides one of the types above a job may be defined as ``EXCLUSIVE``. Exclusive property makes the job to be executed on the scheduler exclusively. It means that there will be no other jobs (strokes or updates) executed in parallel to this one."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:84
msgid "The queue of strokes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:86
msgid "The strokes themselves are stored in a queue and executed one by one. This is important to know that any two jobs owned by different strokes cannot be executed simultaneously. That is the first job of a stroke starts its execution only *after* the last job of the previous stroke has finished."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:92
msgid "The stroke is just a container for jobs. It stores some information about the work done, like ``id()`` and ``name()``. Alongside storing this information it can affect the order of execution of jobs as well. The stroke can be defined *exclusive*. The meaning of this resembles the behavior of stroke job's exclusive property. *Exclusive stroke* is a stroke that executes its jobs with all the updates blocked. The execution of updates will start only after the stroke is finished."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:101
msgid "Implementation (practice)"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:104
msgid "Implementation of a stroke"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:109
#: ../../untranslatable_pages/strokes_documentation.rst:109
msgid "Overview of stroke classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:111
msgid "Each stroke is represented by a ``KisStroke`` object. It has all the basic manipulating methods like: ``addJob()``, ``endStroke()`` and ``cancelStroke()``. The behavior of a stroke is defined by a *stroke strategy* (KisStrokeStrategy class). This strategy is passed to the KisStroke object during construction and owned by the stroke."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:117
msgid "Each stroke job is represented by ``KisStrokeJob`` object. The queue of ``KisStrokeJob`` objects is stored in every stroke object. This very object is used for actual running the job (``KisUpdateJobItem`` calls ``KisStrokeJob::run()`` method while running). The behavior of the stroke job is defined by a strategy (``KisStrokeStrategy``) and a data (``KisStrokeJobData``). Those two objects are passed during the construction of the KisStrokeJob object."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:125
msgid "A stroke can have four types of jobs:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:127
msgid "initialization"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:128
msgid "canceling"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:129
msgid "finishing"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:130
msgid "actual painting (named as 'dab' in the code)"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:132
msgid "During construction the stroke asks its strategy to create strategies for all the four types of job. Then it uses these strategies on creation of jobs on corresponding events: initialization, canceling, finishing and when the user calls ``addJob()`` method."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:137
msgid "The strategies define all the properties of strokes and stroke jobs we were talking above. The data class is used for passing information to the stroke by high-level code."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:141
msgid "**Example:** ``FreehandStrokeStrategy::Data`` accepts such information as: ``node``, ``painter``, ``paintInformation``, ``dragDistance``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:144
msgid "Other information that is common to the whole stroke like names of the paintOp, compositeOp are passed directly to the constructor of the stroke strategy."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:149
msgid "Execution of strokes by ``KisStrokesQueue``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:151
msgid "The key class of the strokes' execution is ``KisStrokesQueue``. The most important method that is responsible for applying all the rules about interleaving of jobs mentioned above is ``KisStrokesQueue::processOneJob``. This method is called by the update scheduler each time a free thread appears. First it gets the number of merge and stroke jobs currently executing in the updater context. Then it checks all the rules one by one."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:160
msgid "Canceling and undo information trick"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:162
msgid "It was stated above that a stroke can be canceled in each moment of time. That happens when a user calls ``KisStroke::cancelStroke()`` method. When it is requested the stroke drops all the jobs those are present in its queue and has not been started yet. Then it enqueues a special kind of job named *cancel job* that reverts all the work done by the stroke. This is used for interactive canceling of tools' strokes."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:169
msgid "Taking into account that the strokes can be reverted, we cannot use ``QUndoStack`` capabilities directly. We should add commands to the stack *after* they have been executed. This resembles the way how ``KisTransactionData`` works: its first redo() method doesn't do anything because everything has already been painted on a device. Here in strokes this \"after-effect-addition\" is implemented in general way. Strokes work with a special kind of undo adapter: ``KisPostExecutionUndoAdapter``. This adapter wraps the commands in a special wrapper that puts them into the stack without calling ``redo()`` and controls their threaded ``undo()`` and ``redo()`` operations. See information about ``KisPostExecutionUndoAdapter`` in a separate document."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:183
msgid "Queues balancing"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:185
msgid "So we ended up with a solution where our scheduler has two queues that it should spread between limited amount of threads. Of course there should be some algorithm that balances the queues. Ideally, we should balance them by the total area of image the queue should process. But we cannot achieve that currently. So the formula for size metrics is quite simple:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:192
msgid "``updatesMetric = <number of update jobs in the queue>``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:194
msgid "``strokesMetric = <number of strokes> * <jobs in the first stroke>``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:196
msgid "Balancing formula:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:198
msgid "``balancingRatio = <updatesMetric> / <strokesMetric>``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:201
msgid "Starting a stroke"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:203
msgid "The main entry point to strokes for the user is ``KisStrokesFacade`` interface. This interfaces provides four methods: ``startStroke()``, ``addJob()``, ``endStroke()`` and ``cancelStroke()``. So every time you work with strokes you should work using this interface."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:208
msgid "**Note:** KisImage and KisUpdateScheduler both implement this interface, so you can use them as a strokes facade. But please try not to store pointers to the whole image. Try store a link to interface only, if possible."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:213
msgid "So if you want to start a stroke you should do the following:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:215
msgid "Create a stroke strategy"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:217
msgid "Start a stroke with:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:219
msgid "``KisStrokeId strokeId = strokesFacade->startStroke(myStrategy);``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:221
msgid "**Note:** you'll get a KisStrokeId handle for the stroke you created. This handle will be used in all the other methods for controlling the stroke. This handle is introduced, because several users can access the strokes facade simultaneously, so there may be several strokes opened simultaneously. It's important to understand that even when several strokes are opened simultaneously, only one of them executes on the cpu. All the other strokes will be delayed until it is finished."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:230
msgid "Create a data for your stroke job"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:232
msgid "Add a job to the execution queue:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:234
msgid "``strokesFacade->addJob(strokeId, myData);``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:236
msgid "You may add as many jobs as you wish"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:238
msgid "End or cancel the stroke:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:240
msgid "``strokesFacade->endStroke(strokeId);``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:242
msgid "or"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:244
msgid "``strokesFacade->cancelStroke(strokeId);``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:247
msgid "Strokes public API"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:250
msgid "Simplified stroke classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:252
msgid "As you might noticed the internal strokes API is quite complex. If you decide to create your own stroke you need to create at least six new classes:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:256
msgid "stroke strategy class"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:257
msgid "four stroke jobs strategies (init, finish, cancel, dab)"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:258
msgid "data that will be passes to a dab-strategy-based job"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:260
msgid "That is not really a good solution for a public API, so we introduced an adapter that simplifies all these stuff. The class is called ``KisSimpleStrokeStrategy``. It allows you to define all the jobs you need in a single class."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:268
#: ../../untranslatable_pages/strokes_documentation.rst:268
msgid "Simple stroke classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:270
msgid "This class has four virtual methods those you can use as callbacks. When you need to use one of them just override it in your own class and add activation of the corresponding callback to the constructor of your class:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:277
msgid "class MyOwnStroke : public KisSimpleStrokeStrategy {\n"
"    MyOwnStroke() {\n"
"        enableJob(KisSimpleStrokeStrategy::JOB_INIT);\n"
"        enableJob(KisSimpleStrokeStrategy::JOB_FINISH);\n"
"        enableJob(KisSimpleStrokeStrategy::JOB_CANCEL);\n"
"        enableJob(KisSimpleStrokeStrategy::JOB_DAB);\n"
"    }\n"
"\n"
"    void initStrokeCallback()\n"
"    {\n"
"    }\n"
"\n"
"    void finishStrokeCallback()\n"
"    {\n"
"    }\n"
"\n"
"    void cancelStrokeCallback()\n"
"    {\n"
"    }\n"
"\n"
"    void doStrokeCallback(KisStrokeJobData *data)\n"
"    {\n"
"        Q_UNUSED(data);\n"
"    }\n"
"};"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:303
msgid "Internally, ``KisSimpleStrokeStrategy`` creates all the job strategies needed for the lowlevel API. And these internal job strategies call the callbacks of the parental class."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:307
msgid "**Important:** Notice that the job data passed to *init*, *finish* and *cancel* jobs is always null. It means that these jobs will always be *sequential* and *non-exclusive*. That is done intentionally to simplify the API. At the same time that is a limitation of the API. But currently, this is perfectly enough for us."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:314
msgid "Unit-testing of the strokes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:316
msgid "One of the benefits of using the strokes is that you are able to test them separately from the UI using a common infrastructure."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:320
msgid "``utils::StrokeTester`` class"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:322
msgid "That is a really simple class that you can use to test your own stroke. It test the following aspects of your stroke:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:325
msgid "canceling of the stroke"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:326
msgid "working with indirect painting activated"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:327
msgid "testing updates of the image projection after your stroke"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:328
msgid "working with a layer that is not connected to any image"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:330
msgid "The result of the execution is compared against the reference png files those you create manually while writing your test."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:334
msgid "How to write your own test"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:336
msgid "You can check examples in ``MoveStrokeTest`` and ``FreehandStrokeTest`` tests."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:339
msgid "You need to inherit your tester class from ``utils::StrokeTester``. The constructor of that class accepts the name of your stroke (it'll be used for generating filenames), size of the image and a filename of the preset for the paintOp."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:346
msgid "StrokeTester(const QString &name, const QSize &imageSize,\n"
"             const QString &presetFileName = \"autobrush_300px.kpp\");"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:349
msgid "Then you need to override at least two methods:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:353
msgid "KisStrokeStrategy* createStroke(bool indirectPainting,\n"
"                                KisResourcesSnapshotSP resources,\n"
"                                KisPainter *painter,\n"
"                                KisImageWSP image);\n"
"void addPaintingJobs(KisImageWSP image,\n"
"                     KisResourcesSnapshotSP resources,\n"
"                     KisPainter *painter);"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:361
msgid "If you thing you need it you may do some corrections for the image and active node in the following method:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:366
msgid "void initImage(KisImageWSP image, KisNodeSP activeNode);"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:368
msgid "Run your test in a testing slot:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:372
msgid "void MyStrokeTest::testStroke()\n"
"{\n"
"    MyTester tester();\n"
"    tester.test();\n"
"}"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:378
msgid "During the first run the test will report you many fails and will generate you several files with actual result of the test. You need to check these files, then move them into the tests' data folder: ``tests/data/<your_stroke_name>/``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:383
msgid "After you copied the files the tester will compare the actual result against these very files. That means it'll catch all the changes in the work of your stroke, so you'll be able to catch all the regressions automatically."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:389
msgid "Predefined classes for usage as base classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:392
#: ../../untranslatable_pages/strokes_documentation.rst:415
msgid "``KisPainterBasedStrokeStrategy``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:394
msgid "This class can be used for the strokes those work with the node using a painter (or painters like in ``KisToolMultihand``). This class accepts resources snapshot (``KisResourcesSnapshot``) and a painter (painters). Initialization, finishing and canceling callbacks of this class do all the work for dealing with indirect painting support, creation of transaction, reverting the stroke on canceling. This base class is used for ``FreehandStroke`` mostly."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:403
#: ../../untranslatable_pages/strokes_documentation.rst:417
msgid "``KisStrokeStrategyUndoCommandBased``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:405
msgid "It is obvious from the name of the class that it works with undo commands. In constructor you define which method of undo command should be used undo() or redo(). Afterwards, you just add commands to the stroke and they are executed with any the sequentiality constraints. This stroke strategy does all the work for adding the commands to the undo adapter and for canceling them if needed."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:413
msgid "Example classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:416
msgid "``FreehandStrokeStrategy``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:418
msgid "``MoveStrokeStrategy``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:421
msgid "Internals of the freehand tool"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:426
#: ../../untranslatable_pages/strokes_documentation.rst:426
msgid "Freehand tool classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:429
msgid "Motivation for so many classes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:431
msgid "We need to share the codebase between at least four classes: ``KisToolFreehand``, ``KisToolMultihand``, ``KisScratchPad``. All these classes paint on a canvas with ``KisPainter``, so they share quite much common code."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:437
msgid "KisResourcesSnapshot"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:439
msgid "After we introduced the strokes, the moments of time when user paints with mouse and when the line is actually painted on the canvas do not coincide. It means that by the time a thread starts actual changing the device, the contents of ``KoCanvasResourceProvider`` might have already changed. So before we start a stroke we should create a snapshot of all the resources we have and pass this snapshot to the stroke."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:446
msgid "For this purpose we introduced ``KisResourcesSnapshot`` class. It solves two problems at the same time: first it stores all the resources we might have and second it encapsulates the algorithm of loading these resources into a ``KisPainter`` object. So this class is really easy to use. You just create the snapshot and then just load all the resources to the painter when needed."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:455
msgid "KisResourcesSnapshotSP resources =\n"
"    new KisResourcesSnapshot(image,\n"
"                             undoAdapter,\n"
"                             resourceManager);\n"
"KisPainter painter;\n"
"painter.begin(device, selection);\n"
"resources->setupPainter(&painter);\n"
"\n"
"// paint something\n"
"\n"
"painter.end();"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:467
msgid "In our implementation this class is usually created by ``KisToolFreehandHelper`` and passed to the ``KisPainterBasedStrokeStrategy`` class. The latter one creates painters and initializes them using ``setupPainter()``."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:473
msgid "``KisToolFreehand`` and ``KisScratchPad``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:475
msgid "The freehand tool is split into four classes:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:478
msgid "``KisToolFreehand``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:478
msgid "highlevel tool class that get the mouse events form the Ko-classes and distributes events among internal classes."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:481
msgid "``KisToolPaintingInformationBuilder``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:481
msgid "converts mouse events represented by ``KoPointerEvent`` objects into ``KisPaintInformation`` objects."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:488
msgid "``KisRecordingAdapter``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:484
msgid "stays in charge of adding recording information into the image's action recorder. This class has two purposes: first we need to be able to disable recording for the scratch pad (then we just pass NULL instead of a recording adapter), second when the strokes are able to do their own recording, it'll be easier to port the freehand tool to it."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:497
msgid "``KisToolFreehandHelper``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:491
msgid "this is the main class that combines all the classes we were talking above. It accepts a mouse event, converts it using a painting information builder into the paint information, notifies recording adapter, takes the snapshot of resources and finally starts a stroke. Then it populates the stroke with stroke jobs, when the user moves the mouse (``paint(event)`` method) and finishes the stroke in the end."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:499
msgid "Such splitting allows us to use the same classes in both ``KisToolFreehand`` and ``KisScratchPad``. The only difference between them is that the scratch pad doesn't have a recording adapter at all, and uses base class ``KisPaintingInformationBuilder`` instead of ``KisToolPaintingInformationBuilder``. The latter differs from the former one in a way that it supports painting assistants (``adjustDocumentPoint()`` method), complex coordinate transformations with ``KisCoordinatesConverter`` (``documentToImage()`` method) and perspective painting (``calculatePerspective()`` method). The rest of the code is shared."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:511
msgid "``KisToolMultihand``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:513
msgid "Multihand tool uses the same classes. The only difference, it has a couple of modifications in its helper (``KisToolMultihandHelper``), those allow it to have several painters at the same time. The tool's class inherits the freehand tool's class and just substitutes the helper with its own (with ``resetHelper()`` method)."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:520
msgid "Scheduled Undo/Redo"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:523
msgid "Two ways of working with undo commands"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:525
msgid "The key problem of designing the undo system for strokes was that there are two ways of working with undo commands. That is we have two types of commands actually:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:529
msgid "*Qt-like command* - command's redo() method is executed while the command is added into the undo stack"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:531
msgid "*Transaction-like command* - the command is added to the stack *after* its action has already been performed. It means that the first redo() of this command (the one that is called by undo stack) does nothing. That is a transaction-like command just saves undo data for the future and does not perform anything on addition."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:537
msgid "You already know that our strokes can be reverted on the go, it means that the stroke's undo command should be added to the undo stack only *after* all the actions of the stroke have been performed. So it looks like the stroke's commands are *transaction-like*."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:542
msgid "But there is another problem: the stroke should be able to execute regular undo commands those are not transaction-like (like is it done in ``KisStrokeStrategyUndoCommand``). More than that, undo and redo of for such strokes should be performed with the same sequentiality properties (read \"undo/redo operations should be threaded as well\")."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:548
msgid "It follows that the undo commands generated by the stroke should be wrapped in a special *wrapper command*, lets call it ``KisSavedCommand``, that hold the following properties:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:552
msgid "the wrapper skips the first redo(). It means the wrapped command's redo() method will not be called on its addition to the stack. Obviously, it is not needed, because the action has already been performed by the stroke itself."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:556
msgid "when undo stack calls to undo/redo methods of the wrapper-command, the command creates a stroke (``KisStrokeStrategyUndoCommandBased``) and runs the wrapped command in a context of this stroke."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:559
msgid "a special *macro wrapper command*, lets call is ``KisSavedMacroCommand``, should be able to save all the commands executed by a stroke and undo/redo all of them in the original order with original sequentiality properties (concurrent, sequential, barrier, exclusive)."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:565
msgid "That is exactly what we have: ``KisSavedUndoCommand`` skips the first redo and runs undo()/redo() of an internal command in a separate stroke. We have ``KisSavedMacroCommand`` as well to save the contents of the whole stroke."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:573
#: ../../untranslatable_pages/strokes_documentation.rst:573
msgid "Scheduled commands"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:576
msgid "New Undo Adapters"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:578
msgid "Well, it would be quite insane to ask all the users of strokes to wrap their commands into wrapper, so we introduced a separate undo adapter for strokes: ``KisPostExecutionUndoAdapter``. This adapter wraps your command and puts it into the undo stack automatically. This is the only adapter we can use inside strokes, that is why all the strokes accept the pointer to it."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:585
msgid "For the legacy code we still have ``KisUndoAdapter``, but now we call it \"legacy undo adapter\". It works as usual: it adds a command to undo stack directly, so it gets executed right in the moment of addition. But there still is one trick. Stroke's commands come to the undo stack asynchronously, so if we try to simply add a command to the stack, we can catch a race condition easily. That's why the legacy undo adapter must guard itself from strokes with locking the strokes system. That is done with a special kind of lock ``barrierLock()``. This barrier lock differs from a regular lock in a way that it ways for all the running *strokes* are finished, while a regular lock waits for all the running *stroke jobs* are done. That's the only difference."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:597
msgid "The same race conditions problem applies to the undo()/redo() signals from the UI. The user may request the undo operation while the stroke is adding its commands. This will surely lead to a crash. We solved this problem in a bit hacky way: we hacked ``QUndoStack`` and made it's undo()/redo() slots virtual. After that we overridden the stack with our own, and changed these methods to block the strokes while undo()/redo() is happening. We use ``tryBarrierLock()`` there, because it is easier to cancel the undo than to wait until all the strokes are finished."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:607
msgid "Undo Adapters and Undo Stores"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:609
msgid "Well, we have two types of undo adapters now (not counting ``KisSurrrogateUndoAdapter``). It's obvious that they should share some code. That is why we split the work with the actual undo stack into a separate class ``KisUndoStore``. So now the undo store defines \"where to store the undo data\", and undo adapter defines \"how to adapt krita's commands to qt's stack\". There are additional types of store classes for using in tests and for special purposes."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:620
#: ../../untranslatable_pages/strokes_documentation.rst:620
msgid "Undo Adapter vs Undo Store"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:623
msgid "Processings framework"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:626
msgid "Motivation"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:628
msgid "In Krita we have many actions which have common structure of execution. Take a look at actions like Scale Image, Rotate Image, Change Color Space - all of them have common phases:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:632
msgid "Lock the image"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:633
msgid "Do the processing of nodes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:634
msgid "Unlock the image"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:635
msgid "Emit setDirty() calls and update the projection of the nodes"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:636
msgid "Wait until all the setDirty()'es are finished"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:637
msgid "Emit image's signals like sigImageSizeChanged"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:639
msgid "More than that, you should pay attention to the fact that all these actions should support undo/redo operations. And the last two phases cannot be implemented as usual qt-commands inside a usual macro, because they should always be executed *in the end* of the action (in qt commands are executed in reverse order during undo operations, that is not what we want)."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:646
msgid "And, btw, it would be really good idea to have multithreading support for such actions, because some of them (like Scale Image) may be quite slow."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:650
msgid "``KisNodeVisitor`` cannot fit all these requirements, because it has important design limitations: first, walking through nodes is implemented inside the visitor itself and, second, emitting signals is put into visitors as well. These two limitations prevent the code to be shared between actions. That is why we introduced new shiny ``KisProcessingVisitor`` and a separate framework for them."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:658
msgid "Processing visitors"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:663
#: ../../untranslatable_pages/strokes_documentation.rst:663
msgid "Processing framework"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:665
msgid "The key class of the processing framework is ``KisProcessingVisitor``. Its main difference from the old visitor is that it is extremely simple. It performs one task only, it processes one node. And that is all. It does no locking, performs no updates, emits no signals. It just processes (that is, changes the content) a single node. You can look at the reference implementation of it in ``KisCropProcessingVisitor`` and ``KisTransformProcessingVisitor``. The key idea of this framework is to keep the processings as simple as possible. So the rest of the work is done by external classes, those are shared between all the processings."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:675
msgid "We have one such class. Its name is ``KisProcessingApplicator``. This class performs several tasks:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:678
msgid "creates a stroke. So all the actions executed with this applicator will be undo/redo'able."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:680
msgid "applies a visitor to a requested node."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:681
msgid "applies a visitor recursively to a node and all its children. Note, that you can choose any sequentiality property for the execution of your visitor. It means that the visitors can be applied to nodes concurrently in multithreaded way."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:685
msgid "applies a usual qt-command to the image. Sequentiality properties may vary as well."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:687
msgid "emits setDirty() calls for all the nodes which need it. It is done in efficient way, so no nodes are updated twice."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:689
msgid "emits image signals *after* all the actions and updates are finished."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:691
msgid "Lets look at an example:"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:695
msgid "void KisImage::resizeImageImpl(const QRect& newRect, bool cropLayers)\n"
"{\n"
"    if(newRect == bounds()) return;\n"
"\n"
"    QString actionName = cropLayers ? i18n(\"Crop Image\") : i18n(\"Resize Image\");\n"
"\n"
"(1) KisImageSignalVector emitSignals;\n"
"(2) emitSignals << SizeChangedSignal << ModifiedSignal;\n"
"\n"
"(3) KisProcessingApplicator applicator(this, m_d->rootLayer,\n"
"                                       KisProcessingApplicator::RECURSIVE,\n"
"                                       emitSignals, actionName);\n"
"\n"
"    if(cropLayers || !newRect.topLeft().isNull()) {\n"
"(4)     KisProcessingVisitorSP visitor =\n"
"            new KisCropProcessingVisitor(newRect, cropLayers, true);\n"
"(5)     applicator.applyVisitor(visitor, KisStrokeJobData::CONCURRENT);\n"
"    }\n"
"(6) applicator.applyCommand(new KisImageResizeCommand(this, newRect.size()));\n"
"(7) applicator.end();\n"
"}"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:717
msgid "In lines (1) and (2) we create a list of signals we should emit after the execution of the applicator. This list should be passed to the *constructor* of the applicator (3) (the list is passed to the constructor instead of end() function, because we face a limitation connected with the internals of the implementation of undo for processings, I doubt it can create any troubles). In the line (3) we create a recursive applicator. In lines (4) and (5) we create a visitor and apply it to nodes recursively in a multithreaded way. **Warning:** the visitor is shared between all the threads so it should be written in a *thread-safe* way. In line (6) we apply a command sequentially, it means that it'll be executed right after *all* the threads with visitors has finished. Line (7) closes the stroke an tells it to perform all the updates and emit all the signals."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:732
msgid "Implementation of ``KisProcessingApplicator``"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:734
msgid "The applicator is based on the \"undo command\"-based stroke (``KisStrokeStrategyUndoCommandBased``). It starts the stroke in the constructor and adds undo commands to it on every user request. The processings are inernally wrapped into a special command (``KisProcessingCommand``). This command has its own undo stack that collects the transactions executed by the processing. This can be easily achieved with our undo adapters interface. The command just defines its own ``KisSurrogateUndoAdapter`` and passes it to the processing. Processing adds its transactions to the fake adapter. And later, the command just uses the undo stack to undo/redo actions executed by the transaction."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:746
msgid "The applicator defines several internal commands as well: ``UpdateCommand`` and ``EmitSignalsCommand``. These commands are added to the beginning and to the end of every stroke, so that they can be executed in the end of both undo and redo operations. The parameter ``finalUpdate`` controls whether the command is executed during its redo() or undo() operation."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:754
msgid "Emission of signals trick"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:756
msgid "After actions have been moved to separate threads, problems with image signals appeared. When everything was executed in a single thread the connection of signals like ``sigAboutToAddNode`` and ``sigNodeHasBeenAdded`` worked as *Qt::DirectConnection*. So these signals were effectively function calls. After we moved the actions to a separate thread, all of them became *Qt::QueuedConnection*. I guess you know what it means. They simply lost all their sense. So we had to start to use *Qt::BlockingQueuedConnection*. But there is another problem with it. Some of the (old) code is still executed in a context of the UI thread and they emit signals as well. So all that code causes deadlocks when using ``Qt::BlockingQueuedConnection``. That is why we had to introduce ``KisImageSignalRouter``. This class checks which thread emits the signal and emits it either using ``Qt::DirectConnection`` or ``Qt::BlockingQueuedConnection``. So no deadlocks are possible."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:772
msgid "Progress reporting"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:774
msgid "The fact that a processing visitor does a really simple task (processes a single node) that is very easy to report progress using progress bars in the layer box. We just need to use progress proxy of the node we process (``KisNodeProgressProxy``). Our processings framework provides an even easier way of doing this. You just need to instantiate a ``ProgressHelper`` object and ask it to create a ``KoUpdater`` object for you. And all is done. You can see an example in ``KisTransformProcessingVisitor`` class."
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:784
msgid "Testing"
msgstr ""

#: ../../untranslatable_pages/strokes_documentation.rst:786
msgid "Usage of a common framework makes testing really simple. There is a separate unittest in image's tests folder: ``KisProcessingsTest``. To test a processing you need to write just a couple of lines. Everything is done by ``BaseProcessingTest`` helper class. This class will run your processing and compare results against reference png files those are stored in data folder. If there are some problems found, it'll dump result files to the current directory."
msgstr ""
