# SOME DESCRIPTIVE TITLE.
# Copyright (C) licensed under the GNU Free Documentation License 1.3+ unless stated otherwise
# This file is distributed under the same license as the Krita Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Krita Manual 5.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-19 22:30+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:3
msgid "bg.. meta::"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:0
msgid "description"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:3
msgid "Guide to using features from C++11, C++14 and beyond in Krita's codebase."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:16
msgid "Modern C++ usage guidelines for the Krita codebase"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:18
msgid "Contents"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:21
msgid "General links about using Modern C++ in Qt"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:23
msgid "There have been a few links discussing mixing C++11 with Qt, and starting with Qt 5.6 C++11 support will be default. *Note:* there is a lot of hype about C++11, and although many of its new features are quite welcome, often the trade-offs from these changes get neglected."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:25
msgid "`ICS.com <https://www.ics.com/blog/qt-and-c11>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:26
msgid "`qt.io <https://blog.qt.io/blog/2011/05/26/cpp0x-in-qt/>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:27
msgid "`woboq.com: c++11 in Qt5 <https://woboq.com/blog/cpp11-in-qt5.html>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:28
msgid "`woboq.com: c++14 in Qt5 <https://woboq.com/blog/cpp14-in-qt.html>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:29
msgid "`FOSDEM 2013 presentation slides <https://archive.fosdem.org/2013/schedule/event/introcplusplus11/attachments/slides/203/export/events/attachments/introcplusplus11/slides/203/fosdem2013_cpp11.pdf>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:32
msgid "Here are some more general purpose guides to C++11 features."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:34
msgid "`C++11 FAQ Bjarne Stroustrup's <http://www.stroustrup.com/C++11FAQ.html>`_ - the grand daddy."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:35
msgid "`Older, more thorough introductions to several topics <https://www.informit.com/authors/bio/e19aded6-574c-4c46-8511-101f9f0ed8f8>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:38
msgid "Qt's API design principles do not always overlap with the C++ Standards Committee design principles. (Range-based for demonstrates the design clash pretty clearly.)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:40
msgid "https://wiki.qt.io/API_Design_Principles"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:43
msgid "Particular Features"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:45
msgid "Under \"drawbacks,\" every item should list: \"Programmers will face another feature they must learn about.\""
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:48
msgid "Type Inference (auto)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:71
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:89
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:123
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:156
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:174
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:192
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:216
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:228
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:247
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:259
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:271
msgid "Motivation:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:51
msgid "If a function ``f`` has a return type Type, it is redundant to write a local variable ``Type x = f(y).``  Using auto declarations is a simplification in two ways scenarios.  First, it allows the programmer to write code without worrying about doing the manual type deduction, for example:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:53
msgid "for( KoXmlReader::const_iterator x = iter.begin(),... ) { }"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:57
msgid "versus:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:59
msgid "for (auto x = iter.begin(), ...) { }"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:63
msgid "This is particularly useful with nested template types and C++11 lambdas, and other complex types which have an obvious role, but a lengthy type definition."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:65
msgid "A second important benefit of auto is that it allows the programmer to more easily refactor.  Suppose we have a function ``gimmeSomeStrings()`` which returns a ``QList<QString>``, and we access it somewhere else like this"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:67
msgid "auto someStrings = gimmeSomeStrings();"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:71
msgid "If we later decide that we want to store a hash of strings and that ``gimmeSomeStrings`` should return a ``QMap<int, QString>``, we probably won't need to make any changes inside the client snippet if we are doing tasks like iterating."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:74
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:92
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:126
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:163
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:177
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:195
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:219
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:231
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:250
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:262
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:286
msgid "Drawbacks:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:74
msgid "the use of auto is be obfuscating.  For example, ``auto x = 2`` is not obviously an integer, and ``auto x = {\"a\", \"b\", \"c\"}`` returns ``std::initializer_list``, and sometimes it is not clear what some function returns by the name of the function."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:77
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:103
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:129
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:168
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:180
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:198
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:222
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:234
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:253
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:265
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:289
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:304
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:310
msgid "Recommendation:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:77
msgid "Do not use auto, except, maybe, in loops, where there can be no confusion about the type of what is looped. But even there, hesitate."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:80
msgid "Range-based for loop"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:83
msgid "This is something a long time coming in C++.  It is a standardized replacement for Qt's foreach() construct, which works not only with Qt objects but all iterable C++ types."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:85
msgid "for (T x : list ) { ... }"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:89
msgid "It will work with standard tooling and static analysis, and can be faster by defaulting to in-place access.  For this reason range-based iterators should always be used for STL containers, if those are ever needed in Krita."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:92
msgid "By default, Qt's foreach rewites the code to make a shallow copy and then use const accessors, while c++11 does the opposite, avoiding copying when possible.  When using const accessors, this is faster, but if you try to make changes to the data, this will `slow your loop down instead <https://www.dvratil.cz/2015/06/qt-containers-and-c11-range-based-loops/>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:95
msgid "Sometimes, the range-based for is faster.  Sometimes the Qt iterator is faster.  Personally I like the range-based for in principle, since it works better with static analysis, it has a faster best-case speed, and it is always possible to write it in a way that replicates the ``foreach()`` behavior, though the reverse is not true."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:97
msgid "On the other hand, there is a bad, dangerous  worst case performance hit when a detach/copy is triggered, and this is not easy to catch with standard syntax. In the blog post linked above, the discussion explains that is possible to get around this limitation by defining a macro ``const_()``, which will gives a new syntax to request the compiler use constant iterators:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:99
msgid "for (T x : _const(list) ) { ... }"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:103
msgid "Qt's recommendation on the other hand is to use foreach() for Qt iterators, and range-based for on STL containers, because you always know what you're getting, and you always keep your syntax easy to read.  In my opinion is the most meaningful new feature without any sort of clear answer, and quite interesting to think about."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:106
msgid "General Initializer Lists"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:109
msgid "Initializer lists are intended to work in many different places to simplify the syntax for complicated initialization.  For example, a list of strings could be initialized ``const QStringList x = {\"abc\", \"def\", \"xyz\"  };`` and if you later changed the type to ``QVector<QString>``, or even ``std::list<std::string>``, you wouldn't have to make any change to the right hand side."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:111
msgid "A second place initializer lists are used is in creating standard initial values for class members.  This takes the place of writing a lengthy constructor list like:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:113
msgid "Type::Type()\n"
" : MemberString1(\"a\")\n"
" , Subclass1(0)\n"
" , Subclass2(1)\n"
" , ..."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:121
msgid "In addition to being more concise, it saves you from repeating yourself, if you have several constructors which all start with the same defaults."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:123
msgid "Mixed uniform initialization is a separate new feature of initializer lists when constructing classes.  It is possible to specify some defaults when you declare member variables, but then override them with delegating constructors. `This MSDN page is a good reference <https://msdn.microsoft.com/en-us/library/dn387583.aspx>`_."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:126
msgid "None I can think of. This is super simple, completely obvious to read and write, and shortens code by removing long unnecessary lists of defaults."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:129
msgid "Yes!"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:132
msgid "Lambdas, and new-style signals/slots"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:135
msgid "Lambda expressions are a big new addition for C++11. Many programmers claim they start to feel like an essential part of the language very quickly. One of the biggest uses for lambdas is in the standard algorithm library <algorithm>, which is described below.  In Qt5, this, along with std::function and std::bind, allow for One of the most useful C++11 integrations, a new signal/slot syntax which replaces the moc macros SIGNAL() and SLOT() with standard C++."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:137
msgid "Old style:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:139
msgid "connect(sender, SIGNAL (valueChanged(QString,QString)),  receiver, SLOT (updateValue(QString)) );"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:143
msgid "New style:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:145
msgid "connect(sender, &Sender::valueChanged, receiver, &Receiver::updateValue );"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:149
msgid "New style signals and slots provide a great benefit from the tooling perspective: now, all types for functions and function arguments can be checked statically, and you don't have to catch typos by monitoring debug messages saying \"no such slot.\""
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:151
msgid "Another possibility is to use lambdas directly inside connect(), instead of defining a class member function which is only used once. The greatest benefit is that the function can be defined right where it is used; it also aids readability to get rid of a list of tiny helper functions from the header."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:153
msgid "`\"Qt5: C++11 lambdas are your friend\" <https://artandlogic.com/2013/09/qt-5-and-c11-lambdas-are-your-friend/>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:154
msgid "`C++ language reference <https://en.cppreference.com/w/cpp/language/lambda>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:155
msgid "`Qt.io New Signal/Slot Syntax <https://wiki.qt.io/New_Signal_Slot_Syntax>`_ Also gives detailed pros/cons."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:159
msgid "The new-style syntax makes it somewhat harder to use default arguments, which requires the use of lambdas.  It is also perhaps a little less pretty."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:161
msgid "Lambdas in general are have become one of the most clunky pieces of C++11 notation. Since they allow a great deal of options for example, capturing by reference with ``[&]`` and capturing by value with ``[=]``, they are a significant new addition to the C++ learning curve. Using small local functions with uninformative names like ``auto F = [&] ( x ) { whatever }`` is confusing for everyone."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:163
msgid "Although it is possible to use lambdas are tricky inside signals and slots, there are gotchas. Lambdas will not disconnect automatically, although there is a special syntax to make that happen."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:166
msgid "Lambdas will feel strange to many C++ programmers. At a minimum, any time you use them you should add a comment explaining what you're doing.  (Krita codebase could use more comments anyway.)  New style signals and slots should be used with caution, especially while the 2.9 branch is being maintained."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:168
msgid "Overall, the Qt wiki gives a good overview, and I agree with its suggestions, which is to permit a small amount of mixing of the different syntax.  Their recommendation is to use new-style signals and slots when possible, which is the vast majority of the time, to fall back on the old macros when one needs to use a default argument, and to use lambdas very rarely, only in cases when one needs to create a signal that is not bound to a particular object.  The latter sort of case is not something that C++ newcomers would want to be touching anyway."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:171
msgid "constexpr"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:174
msgid "Performing calculations at compile time can speed things up at runtime.  `KDAB: speed up your Qt 5 programs using C++11 <https://www.kdab.com/wp-content/uploads/stories/slides/DD12/mutz-dd-speed-up-your-qt-5-programs-using-c++11.pdf>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:177
msgid "Not easy to use these features."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:180
msgid "This could be useful in specific places, like KoCompositeOpRegistry.  Overall it is not something most programmers will run into."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:183
msgid "<algorithm>"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:186
msgid "A handwritten loop that looks for occurences of the number 20 and replaces it with 99 is routine, and will take several lines to write, including defining local variables. Instead, something like"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:188
msgid "std::replace (myvector.cbegin(), myvector.cend(), 20, 99);"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:192
msgid "is more concise, safer  is even self-documenting, since the name of the function itself explains what it is doing. <u>If you make sure to use Qt's const iterators</u>, there should never see a performance penalty compared to a hand-written loop, there can sometimes even see a gain. `A list of standard algorithms can be found here. <http://www.cplusplus.com/reference/algorithm/>`_ Historically Qt provided its own algorithm library, but now encourages programmers to use the STL versions instead, and Qt's own algorithm library will mostly become deprecated. https://doc.qt.io/qt-5/qtalgorithms.html  Unlike range-based for, where it is difficult to specify a const iterator instead of a standard iterator, with ``<algorithm>`` we are easily able to specify the const iterator."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:195
msgid "Some of the standard algorithms are not completely obvious from observing the name.  For example, I could not personally list what are the five arguments of ``std::replace_copy`` off the top of my head, and you shouldn't expect anyone to. When values inside the container need to be modified, non-const iterators may be slower than a Qt foreach() loop."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:198
msgid "Encourage the use of <algorithm> when it improves code clarity.  Speed not a big problem most of the time, don't make changes which are hard to understand just for a tiny hypothetical speed boost.  However, moving to <algorithm> and away from Qt foreach() inside hot paths could prove useful in the future."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:201
msgid "enum class"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:204
msgid "These are a type-safe version of enums, and allows the programmer to associate several different types of data with an enum, such as a character.  This gives stricter type safety, for example, when it might be possible to accidentally convert a variable into a numeric type.  For example:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:206
msgid "enum class Color : char {Red = 'R', Green = 'G', Blue = 'B'};"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:210
msgid "Other benefits of enum classes are that they can be forward-declared, and that the data can be any sort of constexpr.  For example, if one had a constexpr function ``color_symbol()`` that returned the symbol given some color data, the enum class members could be defined like:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:212
msgid "enum class Color: char {Red = color_symbol({255, 0, 0}) ...};"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:216
msgid "The standard C++ reference does a nice job explaining these features. https://en.cppreference.com/w/cpp/language/enum"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:219
msgid "Virtually none.  Very small changes to the code, more type safety, removes the need for some tables of values.  The only problem is sometimes this requires fixing code that was unsafe to begin with."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:222
msgid "Use freely."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:225
msgid "Local type definitions (i.e. using)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:228
msgid "An easier and localized way to use typedefs. Can be at the namespace, class, or function level.  Allows you to rewrite a typedef so that the new name occurs on the left hand side of the equals sign, which is easier to read.  They allow you to place typedefs closer to where they're used. They are particularly nice inside templates."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:231
msgid "Very few.  These are quite intuitive"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:234
msgid "Go for it."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:237
msgid "nullptr"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:240
msgid "The use of nullptr as a default pointer initializer is a very small change in C++11, and mostly an aesthetic one. Technically, there are only a few things it prevents : it cannot be converted to a numeric type like ``int x = nullptr;``, and it cannot be used as a class type in a template, so the following is a compiler error:"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:242
msgid "meta_type<class A, class B>;\n"
"meta_type<C, nullptr> x;"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:247
msgid "The most important to nullptr is simply that you are tagging your code - ''hey: there is a null pointer lurking around here, be careful!''"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:250
msgid "It takes longer to type nullptr than it takes to type 0, and it's not so visually pleasing.  Converting the existing code base would be very laborious and mess up git history. Tiny benefits."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:253
msgid "We do not use nullptr in Krita. Not in new code, and we don't refactor old code to use it. Also not Q_NULLPTR."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:256
msgid "Deleted, default, override, final"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:259
msgid "These are keywords used for designing inheritance patterns. They are useful for preventing accidental copy construction."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:262
msgid "Since Krita does not export libraries, most of the time we won't need to worry about these.  They are limited to solving some pretty specialized problems."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:265
msgid "No reason to hold back from these features if they seem useful. They are well named and fairly self-explanatory, especially for developers with a Java or C# background.  If you apply them correctly, you can prevent other coders from making mistakes when they use your classes.  For others, these definitions can be ignored until they cause a compile error, which tell you that you're doing something the wrong way."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:268
msgid "unique_ptr/QScopedPointer"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:271
msgid "`Here is a glowing review of unique_ptr <https://www.drdobbs.com/cpp/c11-uniqueptr/240002708>`_. This is really about a philosophy of C++ memory management, not just a particular smart pointer type.  The idea is that whenever you create an object on the heap, you should *always* house it inside a smart pointer.  The reason this philosophy is considered new to C++11 is that unique_ptr is the first time they 'got it right' designing a very nice smart pointer class. Most importantly, the class uses negligible overhead. In particular: ``sizeof(unique_ptr<T*>) = size_t``, it can be passed as a function argument without copying, and dereferencing is inline."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:273
msgid "QScopedPointer is essentially the same thing as unique_ptr, and perhaps it is more idiomatic to use QScopedPointer instead."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:277
msgid "It is a useful idiom to store a d-ptr using `QScopedPointer<Private>`, but if you do this you must also declare a destructor in the header file, even if it has an empty implementation in the source file."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:279
msgid "`\"Rule of Zero\": more about the C++ design philosophy behind unique_ptr. <https://rmf.io/cxx11/rule-of-zero/>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:282
msgid "The philosophy mentioned above can be summarized like this: we should state up front what we are going to prohibit programmers from doing.  Like the const keyword, unique_ptr puts restrictions on what can be done with the pointer, the main one being, it cannot be copied. Like enforcing const correctness, this can be annoying to get right throughout a codebase."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:284
msgid "One particular limitation is that Qt container classes.  For example ``QVector<std::unique_ptr>`` is invalid, because QVector requires its members can be copied. This makes converting to unique_ptr a bit slow, since ``QVector<T *>`` will have to be converted to ``std_array<unique_ptr<T*>>``. If the owner was being copied before, it will become uncopiable.  This can be a good thing, but it can also be extra work."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:286
msgid "`Moving a unique_ptr requires additional semantics. <http://www.cplusplus.com/reference/memory/unique_ptr/operator=/>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:289
msgid "Smart pointers are already prevalent in the codebase with the KisSP family, but more use of them should be encouraged.   d_ptrs should be wrapped in a QScopedPointer. The rule is: first Krita's shared pointers, then Qt's, do not use the std smart pointers."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:292
msgid "Performance-related (rvalues)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:294
msgid "Using move constructors and rvalues are very subtle and advanced features, but widely celebrated as successes of C++11.  The point of these features is to save on costs of copying memory when passing function arguments. The idea is that if one is OK allowing a function to steal, alter or destroy its argument, then that function can be called slightly faster if the argument is not copied at all, but instead simply performing an ownership transfer.  C++ programmers should already be aware that writing performant code where data gets shuffled around sometimes requires opening a can of ampersands.  These features will naturally stay confined to the corners of the codebase behind the scenes where they belong, and should be introduced when they are useful."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:296
msgid "`Tutorial for rvalue references <http://thbecker.net/articles/rvalue_references/section_01.html>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:297
msgid "`KDAB: speed up your Qt 5 programs using C++11 <https://www.kdab.com/wp-content/uploads/stories/slides/DD12/mutz-dd-speed-up-your-qt-5-programs-using-c++11.pdf>`_"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:298
msgid "`Slide 37 describes lvalue/rvalue types in exact detail <http://wiki.hsr.ch/PeterSommerlad/files/MeetingCPP2013_SimpleC++.pdf>`_  Also explains the terms \"xvalue\" and \"prvalue\" sometimes seen as well."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:301
msgid "Move Constructors"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:304
#: ../../untranslatable_pages/modern_cpp_in_krita.rst:310
msgid "Use whenever it aids performance."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:307
msgid "Reference Qualifiers (rvalue references)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:313
msgid "C++11 features mostly for template programming"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:315
msgid "Krita makes very light use of templates.  These features are useful, coming across them in the code base will add complexity for new learners, and have not been necessary so far."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:317
msgid "decltype : this is the most likely of these features to be useful, for example, in KisInputManager."
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:318
msgid "static_assert"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:319
msgid "variadic templates"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:322
msgid "Other C++11 features that will not be useful"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:324
msgid "Threading support (Relies on C++ threading model; use Qt threading instead)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:325
msgid "shared_ptr and weak_ptr (Relies on C++ threading model; use KisSharedPointer instead)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:326
msgid "New literal types (already have QString/ki18n)"
msgstr ""

#: ../../untranslatable_pages/modern_cpp_in_krita.rst:327
msgid "Extended Unions (already have QVariant)"
msgstr ""
