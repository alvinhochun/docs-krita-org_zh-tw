

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-TW" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-TW" > <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:title" name="title" content="Modern C++ usage guidelines for the Krita codebase" />
  <meta property="og:site-name" content="Krita Manual" />
  <meta property="og:type" content="article" />
  <meta property="og:locale" content="zh_TW" />
  <meta property="og:locale:alternate" content="ca" />
  <meta property="og:locale:alternate" content="en" />
  <meta property="og:locale:alternate" content="fr" />
  <meta property="og:locale:alternate" content="it" />
  <meta property="og:locale:alternate" content="ja" />
  <meta property="og:locale:alternate" content="ko" />
  <meta property="og:locale:alternate" content="nl" />
  <meta property="og:locale:alternate" content="pl" />
  <meta property="og:locale:alternate" content="pt_PT" />
  <meta property="og:locale:alternate" content="uk_UA" />
  <meta property="og:locale:alternate" content="zh_CN" />
  <meta property="og:article:modified_time" content="2021-10-23T19:26:20" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  
  
  <title>Modern C++ usage guidelines for the Krita codebase &mdash; Krita Manual 5.0.0 說明文件</title>
  

  
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    
  
  
  
    <link rel="canonical" href="zh_TW/untranslatable_pages/modern_cpp_in_krita.html"/>
    <meta property="og:url" content="zh_TW/untranslatable_pages/modern_cpp_in_krita.html" />
    <meta property="og:image" content="zh_TW/_static/sidebar-logo.png" />
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="Developing Features" href="new_features.html" />
    <link rel="prev" title="Krita SVG Extensions" href="krita_svg_extensions.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          
       
           <a href="../index.html" class="icon icon-home">

			<img src="../_static/sidebar-logo.png" class="logo" alt="Logo"/>
           	
           <!--	Krita Manual -->


          </a>


          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜尋文件" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-side-nav-language-selector">
        	<p class="caption-text">
	        	<select id="language-selector-container">
	        		<option value="ca">Català</option>
	        		<option value="en">English</option>
	        		<option value="fr">français</option>
	        		<option value="it">Italiano</option>
	        		<option value="ja">日本語</option>
	        		<option value="ko">한국어</option>
	        		<option value="nl">Nederlands</option>
	        		<option value="pl">Polski</option>
	        		<option value="pt_PT">português</option>
	        		<option value="uk_UA">Українська</option>
	        		<option value="zh_CN">简体中文</option>
	        	</select>
        	</p>
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user_manual.html">使用者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../general_concepts.html">通用概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference_manual.html">參考文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">教學及指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../KritaFAQ.html">Krita 常見問題</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../contributors_manual.html">貢獻者手冊</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../contributors_manual/community.html">Krita 的社群</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors_manual/krita_manual_conventions.html">Krita 說明文件標記格式使用慣例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors_manual/krita_manual_readme.html">Krita 說明文件貢獻指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors_manual/optimising_images.html">供說明文件使用的影像</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors_manual/user_support.html">使用者支援入門介紹</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../untranslatable_pages.html">Technical Pages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="building_krita.html">Building Krita from Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="cmake_settings_for_developers.html">CMake Settings for Developers</a></li>
<li class="toctree-l3"><a class="reference internal" href="enable_static_analyzer.html">Enable static analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro_hacking_krita.html">Introduction to Hacking Krita</a></li>
<li class="toctree-l3"><a class="reference internal" href="kpl_defintion.html">The Krita Palette format KPL</a></li>
<li class="toctree-l3"><a class="reference internal" href="krita_svg_extensions.html">Krita SVG Extensions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Modern C++ usage guidelines for the Krita codebase</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#general-links-about-using-modern-c-in-qt">General links about using Modern C++ in Qt</a></li>
<li class="toctree-l4"><a class="reference internal" href="#particular-features">Particular Features</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="new_features.html">Developing Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="optimizing_tips_for_krita.html">Optimizing tips and tools for Krita</a></li>
<li class="toctree-l3"><a class="reference internal" href="participating_in_gsoc.html">Google Summer of Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="patch_review_guide.html">Advanced Merge Request Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_coding.html">Python Developer Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="quality_assurance.html">Introduction to Quality Assurance</a></li>
<li class="toctree-l3"><a class="reference internal" href="release_krita.html">Making a release</a></li>
<li class="toctree-l3"><a class="reference internal" href="reporting_bugs.html">Reporting Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="running_krita.html">Running Krita from Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="strokes_documentation.html">Strokes queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="strokes_documentation.html#strokes-public-api">Strokes public API</a></li>
<li class="toctree-l3"><a class="reference internal" href="strokes_documentation.html#internals-of-the-freehand-tool">Internals of the freehand tool</a></li>
<li class="toctree-l3"><a class="reference internal" href="strokes_documentation.html#scheduled-undo-redo">Scheduled Undo/Redo</a></li>
<li class="toctree-l3"><a class="reference internal" href="strokes_documentation.html#processings-framework">Processings framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing_strategy.html">Testing Strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="triaging_bugs.html">Triaging Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="unit_tests_in_krita.html">Unittests in Krita</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../resources_page.html">資源</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

	<!-- start top banner area (for fundraisers or messages)

	<div style="text-align: center; background-color: #333">
		<a href="https://krita.org/en/fundraising-2018-campaign/" target="_self" onclick="ga('send', 'event', 'frontpage', 'button', 'Fundraiser 2018');">
			<img src="https://krita.org/wp-content/themes/krita-org-theme/images/decoration/2018-fundraiser-banner.png" style="max-width: 100%">
		</a>
	</div>
	
	 end top banner area -->

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Krita Manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">文件</a> &raquo;</li>
        
          <li><a href="../contributors_manual.html">貢獻者手冊</a> &raquo;</li>
        
          <li><a href="../untranslatable_pages.html">Technical Pages</a> &raquo;</li>
        
      <li>Modern C++ usage guidelines for the Krita codebase</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
          
            <a href="../_sources/untranslatable_pages/modern_cpp_in_krita.rst.txt" rel="nofollow"> 
             
              <img src="../_static/images/source-code.png" />
             <!-- 檢視頁面原始碼 -->

          </a>
          
        
      </li>
    
  </ul>

  
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <dl class="simple">
<dt>bg.. meta::</dt><dd><dl class="field-list simple">
<dt class="field-odd">description</dt>
<dd class="field-odd"><p>Guide to using features from C++11, C++14 and beyond in Krita's codebase.</p>
</dd>
</dl>
</dd>
</dl>
<section id="modern-c-usage-guidelines-for-the-krita-codebase">
<span id="modern-cpp-in-krita"></span><h1><a class="toc-backref" href="#id3">Modern C++ usage guidelines for the Krita codebase</a><a class="headerlink" href="#modern-c-usage-guidelines-for-the-krita-codebase" title="本標題的永久連結">¶</a></h1>
<div class="contents topic" id="id1">
<p class="topic-title">目錄</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modern-c-usage-guidelines-for-the-krita-codebase" id="id3">Modern C++ usage guidelines for the Krita codebase</a></p>
<ul>
<li><p><a class="reference internal" href="#general-links-about-using-modern-c-in-qt" id="id4">General links about using Modern C++ in Qt</a></p></li>
<li><p><a class="reference internal" href="#particular-features" id="id5">Particular Features</a></p>
<ul>
<li><p><a class="reference internal" href="#type-inference-auto" id="id6">Type Inference (auto)</a></p></li>
<li><p><a class="reference internal" href="#range-based-for-loop" id="id7">Range-based for loop</a></p></li>
<li><p><a class="reference internal" href="#general-initializer-lists" id="id8">General Initializer Lists</a></p></li>
<li><p><a class="reference internal" href="#lambdas-and-new-style-signals-slots" id="id9">Lambdas, and new-style signals/slots</a></p></li>
<li><p><a class="reference internal" href="#constexpr" id="id10">constexpr</a></p></li>
<li><p><a class="reference internal" href="#algorithm" id="id11">&lt;algorithm&gt;</a></p></li>
<li><p><a class="reference internal" href="#enum-class" id="id12">enum class</a></p></li>
<li><p><a class="reference internal" href="#local-type-definitions-i-e-using" id="id13">Local type definitions (i.e. using)</a></p></li>
<li><p><a class="reference internal" href="#nullptr" id="id14">nullptr</a></p></li>
<li><p><a class="reference internal" href="#deleted-default-override-final" id="id15">Deleted, default, override, final</a></p></li>
<li><p><a class="reference internal" href="#unique-ptr-qscopedpointer" id="id16">unique_ptr/QScopedPointer</a></p></li>
<li><p><a class="reference internal" href="#performance-related-rvalues" id="id17">Performance-related (rvalues)</a></p>
<ul>
<li><p><a class="reference internal" href="#move-constructors" id="id18">Move Constructors</a></p></li>
<li><p><a class="reference internal" href="#reference-qualifiers-rvalue-references" id="id19">Reference Qualifiers (rvalue references)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-11-features-mostly-for-template-programming" id="id20">C++11 features mostly for template programming</a></p></li>
<li><p><a class="reference internal" href="#other-c-11-features-that-will-not-be-useful" id="id21">Other C++11 features that will not be useful</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="general-links-about-using-modern-c-in-qt">
<h2><a class="toc-backref" href="#id4">General links about using Modern C++ in Qt</a><a class="headerlink" href="#general-links-about-using-modern-c-in-qt" title="本標題的永久連結">¶</a></h2>
<p>There have been a few links discussing mixing C++11 with Qt, and starting with Qt 5.6 C++11 support will be default. <em>Note:</em> there is a lot of hype about C++11, and although many of its new features are quite welcome, often the trade-offs from these changes get neglected.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.ics.com/blog/qt-and-c11">ICS.com</a></p></li>
<li><p><a class="reference external" href="https://blog.qt.io/blog/2011/05/26/cpp0x-in-qt/">qt.io</a></p></li>
<li><p><a class="reference external" href="https://woboq.com/blog/cpp11-in-qt5.html">woboq.com: c++11 in Qt5</a>.</p></li>
<li><p><a class="reference external" href="https://woboq.com/blog/cpp14-in-qt.html">woboq.com: c++14 in Qt5</a>.</p></li>
<li><p><a class="reference external" href="https://archive.fosdem.org/2013/schedule/event/introcplusplus11/attachments/slides/203/export/events/attachments/introcplusplus11/slides/203/fosdem2013_cpp11.pdf">FOSDEM 2013 presentation slides</a>.</p></li>
</ul>
<p>Here are some more general purpose guides to C++11 features.</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ Bjarne Stroustrup's</a> - the grand daddy.</p></li>
<li><p><a class="reference external" href="https://www.informit.com/authors/bio/e19aded6-574c-4c46-8511-101f9f0ed8f8">Older, more thorough introductions to several topics</a>.</p></li>
</ul>
<p>Qt's API design principles do not always overlap with the C++ Standards Committee design principles. (Range-based for demonstrates the design clash pretty clearly.)</p>
<ul class="simple">
<li><p><a class="reference external" href="https://wiki.qt.io/API_Design_Principles">https://wiki.qt.io/API_Design_Principles</a></p></li>
</ul>
</section>
<section id="particular-features">
<h2><a class="toc-backref" href="#id5">Particular Features</a><a class="headerlink" href="#particular-features" title="本標題的永久連結">¶</a></h2>
<p>Under &quot;drawbacks,&quot; every item should list: &quot;Programmers will face another feature they must learn about.&quot;</p>
<section id="type-inference-auto">
<h3><a class="toc-backref" href="#id6">Type Inference (auto)</a><a class="headerlink" href="#type-inference-auto" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>If a function <code class="docutils literal notranslate"><span class="pre">f</span></code> has a return type Type, it is redundant to write a local variable <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f(y).</span></code>  Using auto declarations is a simplification in two ways scenarios.  First, it allows the programmer to write code without worrying about doing the manual type deduction, for example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span> <span class="n">KoXmlReader</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">x</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">begin</span><span class="p">(),...</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>versus:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">...)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>This is particularly useful with nested template types and C++11 lambdas, and other complex types which have an obvious role, but a lengthy type definition.</p>
<p>A second important benefit of auto is that it allows the programmer to more easily refactor.  Suppose we have a function <code class="docutils literal notranslate"><span class="pre">gimmeSomeStrings()</span></code> which returns a <code class="docutils literal notranslate"><span class="pre">QList&lt;QString&gt;</span></code>, and we access it somewhere else like this</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">someStrings</span> <span class="o">=</span> <span class="n">gimmeSomeStrings</span><span class="p">();</span>
</pre></div>
</div>
<p>If we later decide that we want to store a hash of strings and that <code class="docutils literal notranslate"><span class="pre">gimmeSomeStrings</span></code> should return a <code class="docutils literal notranslate"><span class="pre">QMap&lt;int,</span> <span class="pre">QString&gt;</span></code>, we probably won't need to make any changes inside the client snippet if we are doing tasks like iterating.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>the use of auto is be obfuscating.  For example, <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code> is not obviously an integer, and <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;}</span></code> returns <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>, and sometimes it is not clear what some function returns by the name of the function.</p>
</dd>
<dt>Recommendation:</dt><dd><p>Do not use auto, except, maybe, in loops, where there can be no confusion about the type of what is looped. But even there, hesitate.</p>
</dd>
</dl>
</section>
<section id="range-based-for-loop">
<h3><a class="toc-backref" href="#id7">Range-based for loop</a><a class="headerlink" href="#range-based-for-loop" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>This is something a long time coming in C++.  It is a standardized replacement for Qt's foreach() construct, which works not only with Qt objects but all iterable C++ types.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">T</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">list</span> <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>It will work with standard tooling and static analysis, and can be faster by defaulting to in-place access.  For this reason range-based iterators should always be used for STL containers, if those are ever needed in Krita.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>By default, Qt's foreach rewites the code to make a shallow copy and then use const accessors, while c++11 does the opposite, avoiding copying when possible.  When using const accessors, this is faster, but if you try to make changes to the data, this will <a class="reference external" href="https://www.dvratil.cz/2015/06/qt-containers-and-c11-range-based-loops/">slow your loop down instead</a>.</p>
</dd>
<dt>Recommendation:</dt><dd><blockquote>
<div><p>Sometimes, the range-based for is faster.  Sometimes the Qt iterator is faster.  Personally I like the range-based for in principle, since it works better with static analysis, it has a faster best-case speed, and it is always possible to write it in a way that replicates the <code class="docutils literal notranslate"><span class="pre">foreach()</span></code> behavior, though the reverse is not true.</p>
</div></blockquote>
<p>On the other hand, there is a bad, dangerous  worst case performance hit when a detach/copy is triggered, and this is not easy to catch with standard syntax. In the blog post linked above, the discussion explains that is possible to get around this limitation by defining a macro <code class="docutils literal notranslate"><span class="pre">const_()</span></code>, which will gives a new syntax to request the compiler use constant iterators:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">T</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">_const</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>Qt's recommendation on the other hand is to use foreach() for Qt iterators, and range-based for on STL containers, because you always know what you're getting, and you always keep your syntax easy to read.  In my opinion is the most meaningful new feature without any sort of clear answer, and quite interesting to think about.</p>
</dd>
</dl>
</section>
<section id="general-initializer-lists">
<h3><a class="toc-backref" href="#id8">General Initializer Lists</a><a class="headerlink" href="#general-initializer-lists" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>Initializer lists are intended to work in many different places to simplify the syntax for complicated initialization.  For example, a list of strings could be initialized <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">QStringList</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{&quot;abc&quot;,</span> <span class="pre">&quot;def&quot;,</span> <span class="pre">&quot;xyz&quot;</span>&#160; <span class="pre">};</span></code> and if you later changed the type to <code class="docutils literal notranslate"><span class="pre">QVector&lt;QString&gt;</span></code>, or even <code class="docutils literal notranslate"><span class="pre">std::list&lt;std::string&gt;</span></code>, you wouldn't have to make any change to the right hand side.</p>
<p>A second place initializer lists are used is in creating standard initial values for class members.  This takes the place of writing a lengthy constructor list like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="o">::</span><span class="n">Type</span><span class="p">()</span>
 <span class="o">:</span> <span class="n">MemberString1</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
 <span class="p">,</span> <span class="n">Subclass1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
 <span class="p">,</span> <span class="n">Subclass2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
 <span class="p">,</span> <span class="p">...</span>
</pre></div>
</div>
<p>In addition to being more concise, it saves you from repeating yourself, if you have several constructors which all start with the same defaults.</p>
<p>Mixed uniform initialization is a separate new feature of initializer lists when constructing classes.  It is possible to specify some defaults when you declare member variables, but then override them with delegating constructors. <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn387583.aspx">This MSDN page is a good reference</a>.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>None I can think of. This is super simple, completely obvious to read and write, and shortens code by removing long unnecessary lists of defaults.</p>
</dd>
<dt>Recommendation:</dt><dd><p>Yes!</p>
</dd>
</dl>
</section>
<section id="lambdas-and-new-style-signals-slots">
<h3><a class="toc-backref" href="#id9">Lambdas, and new-style signals/slots</a><a class="headerlink" href="#lambdas-and-new-style-signals-slots" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><blockquote>
<div><p>Lambda expressions are a big new addition for C++11. Many programmers claim they start to feel like an essential part of the language very quickly. One of the biggest uses for lambdas is in the standard algorithm library &lt;algorithm&gt;, which is described below.  In Qt5, this, along with std::function and std::bind, allow for One of the most useful C++11 integrations, a new signal/slot syntax which replaces the moc macros SIGNAL() and SLOT() with standard C++.</p>
</div></blockquote>
<p>Old style:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">SIGNAL</span> <span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="n">QString</span><span class="p">,</span><span class="n">QString</span><span class="p">)),</span>  <span class="n">receiver</span><span class="p">,</span> <span class="n">SLOT</span> <span class="p">(</span><span class="n">updateValue</span><span class="p">(</span><span class="n">QString</span><span class="p">))</span> <span class="p">);</span>
</pre></div>
</div>
<p>New style:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">::</span><span class="n">valueChanged</span><span class="p">,</span> <span class="n">receiver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Receiver</span><span class="o">::</span><span class="n">updateValue</span> <span class="p">);</span>
</pre></div>
</div>
<p>New style signals and slots provide a great benefit from the tooling perspective: now, all types for functions and function arguments can be checked statically, and you don't have to catch typos by monitoring debug messages saying &quot;no such slot.&quot;</p>
<p>Another possibility is to use lambdas directly inside connect(), instead of defining a class member function which is only used once. The greatest benefit is that the function can be defined right where it is used; it also aids readability to get rid of a list of tiny helper functions from the header.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://artandlogic.com/2013/09/qt-5-and-c11-lambdas-are-your-friend/">&quot;Qt5: C++11 lambdas are your friend&quot;</a></p></li>
<li><p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/lambda">C++ language reference</a></p></li>
<li><p><a class="reference external" href="https://wiki.qt.io/New_Signal_Slot_Syntax">Qt.io New Signal/Slot Syntax</a> Also gives detailed pros/cons.</p></li>
</ul>
</dd>
<dt>Drawbacks:</dt><dd><p>The new-style syntax makes it somewhat harder to use default arguments, which requires the use of lambdas.  It is also perhaps a little less pretty.</p>
<p>Lambdas in general are have become one of the most clunky pieces of C++11 notation. Since they allow a great deal of options for example, capturing by reference with <code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code> and capturing by value with <code class="docutils literal notranslate"><span class="pre">[=]</span></code>, they are a significant new addition to the C++ learning curve. Using small local functions with uninformative names like <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">F</span> <span class="pre">=</span> <span class="pre">[&amp;]</span> <span class="pre">(</span> <span class="pre">x</span> <span class="pre">)</span> <span class="pre">{</span> <span class="pre">whatever</span> <span class="pre">}</span></code> is confusing for everyone.</p>
<p>Although it is possible to use lambdas are tricky inside signals and slots, there are gotchas. Lambdas will not disconnect automatically, although there is a special syntax to make that happen.</p>
</dd>
<dt>Recommendation:</dt><dd><p>Lambdas will feel strange to many C++ programmers. At a minimum, any time you use them you should add a comment explaining what you're doing.  (Krita codebase could use more comments anyway.)  New style signals and slots should be used with caution, especially while the 2.9 branch is being maintained.</p>
<p>Overall, the Qt wiki gives a good overview, and I agree with its suggestions, which is to permit a small amount of mixing of the different syntax.  Their recommendation is to use new-style signals and slots when possible, which is the vast majority of the time, to fall back on the old macros when one needs to use a default argument, and to use lambdas very rarely, only in cases when one needs to create a signal that is not bound to a particular object.  The latter sort of case is not something that C++ newcomers would want to be touching anyway.</p>
</dd>
</dl>
</section>
<section id="constexpr">
<h3><a class="toc-backref" href="#id10">constexpr</a><a class="headerlink" href="#constexpr" title="本標題的永久連結">¶</a></h3>
<dl class="simple">
<dt>Motivation:</dt><dd><p>Performing calculations at compile time can speed things up at runtime.  <a class="reference external" href="https://www.kdab.com/wp-content/uploads/stories/slides/DD12/mutz-dd-speed-up-your-qt-5-programs-using-c++11.pdf">KDAB: speed up your Qt 5 programs using C++11</a></p>
</dd>
<dt>Drawbacks:</dt><dd><p>Not easy to use these features.</p>
</dd>
<dt>Recommendation:</dt><dd><p>This could be useful in specific places, like KoCompositeOpRegistry.  Overall it is not something most programmers will run into.</p>
</dd>
</dl>
</section>
<section id="algorithm">
<h3><a class="toc-backref" href="#id11">&lt;algorithm&gt;</a><a class="headerlink" href="#algorithm" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>A handwritten loop that looks for occurences of the number 20 and replaces it with 99 is routine, and will take several lines to write, including defining local variables. Instead, something like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">replace</span> <span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span>
</pre></div>
</div>
<p>is more concise, safer  is even self-documenting, since the name of the function itself explains what it is doing. &lt;u&gt;If you make sure to use Qt's const iterators&lt;/u&gt;, there should never see a performance penalty compared to a hand-written loop, there can sometimes even see a gain. <a class="reference external" href="http://www.cplusplus.com/reference/algorithm/">A list of standard algorithms can be found here.</a> Historically Qt provided its own algorithm library, but now encourages programmers to use the STL versions instead, and Qt's own algorithm library will mostly become deprecated. <a class="reference external" href="https://doc.qt.io/qt-5/qtalgorithms.html">https://doc.qt.io/qt-5/qtalgorithms.html</a>  Unlike range-based for, where it is difficult to specify a const iterator instead of a standard iterator, with <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> we are easily able to specify the const iterator.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>Some of the standard algorithms are not completely obvious from observing the name.  For example, I could not personally list what are the five arguments of <code class="docutils literal notranslate"><span class="pre">std::replace_copy</span></code> off the top of my head, and you shouldn't expect anyone to. When values inside the container need to be modified, non-const iterators may be slower than a Qt foreach() loop.</p>
</dd>
<dt>Recommendation:</dt><dd><p>Encourage the use of &lt;algorithm&gt; when it improves code clarity.  Speed not a big problem most of the time, don't make changes which are hard to understand just for a tiny hypothetical speed boost.  However, moving to &lt;algorithm&gt; and away from Qt foreach() inside hot paths could prove useful in the future.</p>
</dd>
</dl>
</section>
<section id="enum-class">
<h3><a class="toc-backref" href="#id12">enum class</a><a class="headerlink" href="#enum-class" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>These are a type-safe version of enums, and allows the programmer to associate several different types of data with an enum, such as a character.  This gives stricter type safety, for example, when it might be possible to accidentally convert a variable into a numeric type.  For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span><span class="n">Red</span> <span class="o">=</span> <span class="sc">&#39;R&#39;</span><span class="p">,</span> <span class="n">Green</span> <span class="o">=</span> <span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="n">Blue</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">};</span>
</pre></div>
</div>
<p>Other benefits of enum classes are that they can be forward-declared, and that the data can be any sort of constexpr.  For example, if one had a constexpr function <code class="docutils literal notranslate"><span class="pre">color_symbol()</span></code> that returned the symbol given some color data, the enum class members could be defined like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span><span class="o">:</span> <span class="kt">char</span> <span class="p">{</span><span class="n">Red</span> <span class="o">=</span> <span class="n">color_symbol</span><span class="p">({</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">})</span> <span class="p">...};</span>
</pre></div>
</div>
<p>The standard C++ reference does a nice job explaining these features. <a class="reference external" href="https://en.cppreference.com/w/cpp/language/enum">https://en.cppreference.com/w/cpp/language/enum</a></p>
</dd>
<dt>Drawbacks:</dt><dd><p>Virtually none.  Very small changes to the code, more type safety, removes the need for some tables of values.  The only problem is sometimes this requires fixing code that was unsafe to begin with.</p>
</dd>
<dt>Recommendation:</dt><dd><p>Use freely.</p>
</dd>
</dl>
</section>
<section id="local-type-definitions-i-e-using">
<h3><a class="toc-backref" href="#id13">Local type definitions (i.e. using)</a><a class="headerlink" href="#local-type-definitions-i-e-using" title="本標題的永久連結">¶</a></h3>
<dl class="simple">
<dt>Motivation:</dt><dd><p>An easier and localized way to use typedefs. Can be at the namespace, class, or function level.  Allows you to rewrite a typedef so that the new name occurs on the left hand side of the equals sign, which is easier to read.  They allow you to place typedefs closer to where they're used. They are particularly nice inside templates.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>Very few.  These are quite intuitive</p>
</dd>
<dt>Recommendation:</dt><dd><p>Go for it.</p>
</dd>
</dl>
</section>
<section id="nullptr">
<h3><a class="toc-backref" href="#id14">nullptr</a><a class="headerlink" href="#nullptr" title="本標題的永久連結">¶</a></h3>
<dl>
<dt>Motivation:</dt><dd><p>The use of nullptr as a default pointer initializer is a very small change in C++11, and mostly an aesthetic one. Technically, there are only a few things it prevents : it cannot be converted to a numeric type like <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">nullptr;</span></code>, and it cannot be used as a class type in a template, so the following is a compiler error:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">meta_type</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">B</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">meta_type</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="k">nullptr</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>The most important to nullptr is simply that you are tagging your code - ''hey: there is a null pointer lurking around here, be careful!''</p>
</dd>
<dt>Drawbacks:</dt><dd><p>It takes longer to type nullptr than it takes to type 0, and it's not so visually pleasing.  Converting the existing code base would be very laborious and mess up git history. Tiny benefits.</p>
</dd>
<dt>Recommendation:</dt><dd><p>We do not use nullptr in Krita. Not in new code, and we don't refactor old code to use it. Also not Q_NULLPTR.</p>
</dd>
</dl>
</section>
<section id="deleted-default-override-final">
<h3><a class="toc-backref" href="#id15">Deleted, default, override, final</a><a class="headerlink" href="#deleted-default-override-final" title="本標題的永久連結">¶</a></h3>
<dl class="simple">
<dt>Motivation:</dt><dd><p>These are keywords used for designing inheritance patterns. They are useful for preventing accidental copy construction.</p>
</dd>
<dt>Drawbacks:</dt><dd><p>Since Krita does not export libraries, most of the time we won't need to worry about these.  They are limited to solving some pretty specialized problems.</p>
</dd>
<dt>Recommendation:</dt><dd><p>No reason to hold back from these features if they seem useful. They are well named and fairly self-explanatory, especially for developers with a Java or C# background.  If you apply them correctly, you can prevent other coders from making mistakes when they use your classes.  For others, these definitions can be ignored until they cause a compile error, which tell you that you're doing something the wrong way.</p>
</dd>
</dl>
</section>
<section id="unique-ptr-qscopedpointer">
<h3><a class="toc-backref" href="#id16">unique_ptr/QScopedPointer</a><a class="headerlink" href="#unique-ptr-qscopedpointer" title="本標題的永久連結">¶</a></h3>
<dl class="simple">
<dt>Motivation:</dt><dd><p><a class="reference external" href="https://www.drdobbs.com/cpp/c11-uniqueptr/240002708">Here is a glowing review of unique_ptr</a>. This is really about a philosophy of C++ memory management, not just a particular smart pointer type.  The idea is that whenever you create an object on the heap, you should <em>always</em> house it inside a smart pointer.  The reason this philosophy is considered new to C++11 is that unique_ptr is the first time they 'got it right' designing a very nice smart pointer class. Most importantly, the class uses negligible overhead. In particular: <code class="docutils literal notranslate"><span class="pre">sizeof(unique_ptr&lt;T*&gt;)</span> <span class="pre">=</span> <span class="pre">size_t</span></code>, it can be passed as a function argument without copying, and dereferencing is inline.</p>
</dd>
</dl>
<p>QScopedPointer is essentially the same thing as unique_ptr, and perhaps it is more idiomatic to use QScopedPointer instead.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>It is a useful idiom to store a d-ptr using <cite>QScopedPointer&lt;Private&gt;</cite>, but if you do this you must also declare a destructor in the header file, even if it has an empty implementation in the source file.</p>
<p><a class="reference external" href="https://rmf.io/cxx11/rule-of-zero/">&quot;Rule of Zero&quot;: more about the C++ design philosophy behind unique_ptr.</a></p>
</div>
<dl>
<dt>Drawbacks:</dt><dd><p>The philosophy mentioned above can be summarized like this: we should state up front what we are going to prohibit programmers from doing.  Like the const keyword, unique_ptr puts restrictions on what can be done with the pointer, the main one being, it cannot be copied. Like enforcing const correctness, this can be annoying to get right throughout a codebase.</p>
<p>One particular limitation is that Qt container classes.  For example <code class="docutils literal notranslate"><span class="pre">QVector&lt;std::unique_ptr&gt;</span></code> is invalid, because QVector requires its members can be copied. This makes converting to unique_ptr a bit slow, since <code class="docutils literal notranslate"><span class="pre">QVector&lt;T</span> <span class="pre">*&gt;</span></code> will have to be converted to <code class="docutils literal notranslate"><span class="pre">std_array&lt;unique_ptr&lt;T*&gt;&gt;</span></code>. If the owner was being copied before, it will become uncopiable.  This can be a good thing, but it can also be extra work.</p>
<p><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/operator=/">Moving a unique_ptr requires additional semantics.</a></p>
</dd>
<dt>Recommendation:</dt><dd><p>Smart pointers are already prevalent in the codebase with the KisSP family, but more use of them should be encouraged.   d_ptrs should be wrapped in a QScopedPointer. The rule is: first Krita's shared pointers, then Qt's, do not use the std smart pointers.</p>
</dd>
</dl>
</section>
<section id="performance-related-rvalues">
<h3><a class="toc-backref" href="#id17">Performance-related (rvalues)</a><a class="headerlink" href="#performance-related-rvalues" title="本標題的永久連結">¶</a></h3>
<p>Using move constructors and rvalues are very subtle and advanced features, but widely celebrated as successes of C++11.  The point of these features is to save on costs of copying memory when passing function arguments. The idea is that if one is OK allowing a function to steal, alter or destroy its argument, then that function can be called slightly faster if the argument is not copied at all, but instead simply performing an ownership transfer.  C++ programmers should already be aware that writing performant code where data gets shuffled around sometimes requires opening a can of ampersands.  These features will naturally stay confined to the corners of the codebase behind the scenes where they belong, and should be introduced when they are useful.</p>
<ul class="simple">
<li><p><a class="reference external" href="http://thbecker.net/articles/rvalue_references/section_01.html">Tutorial for rvalue references</a></p></li>
<li><p><a class="reference external" href="https://www.kdab.com/wp-content/uploads/stories/slides/DD12/mutz-dd-speed-up-your-qt-5-programs-using-c++11.pdf">KDAB: speed up your Qt 5 programs using C++11</a></p></li>
<li><p><a class="reference external" href="http://wiki.hsr.ch/PeterSommerlad/files/MeetingCPP2013_SimpleC++.pdf">Slide 37 describes lvalue/rvalue types in exact detail</a>  Also explains the terms &quot;xvalue&quot; and &quot;prvalue&quot; sometimes seen as well.</p></li>
</ul>
<section id="move-constructors">
<h4><a class="toc-backref" href="#id18">Move Constructors</a><a class="headerlink" href="#move-constructors" title="本標題的永久連結">¶</a></h4>
<dl class="simple">
<dt>Recommendation:</dt><dd><p>Use whenever it aids performance.</p>
</dd>
</dl>
</section>
<section id="reference-qualifiers-rvalue-references">
<h4><a class="toc-backref" href="#id19">Reference Qualifiers (rvalue references)</a><a class="headerlink" href="#reference-qualifiers-rvalue-references" title="本標題的永久連結">¶</a></h4>
<dl class="simple">
<dt>Recommendation:</dt><dd><p>Use whenever it aids performance.</p>
</dd>
</dl>
</section>
</section>
<section id="c-11-features-mostly-for-template-programming">
<h3><a class="toc-backref" href="#id20">C++11 features mostly for template programming</a><a class="headerlink" href="#c-11-features-mostly-for-template-programming" title="本標題的永久連結">¶</a></h3>
<p>Krita makes very light use of templates.  These features are useful, coming across them in the code base will add complexity for new learners, and have not been necessary so far.</p>
<ul class="simple">
<li><p>decltype : this is the most likely of these features to be useful, for example, in KisInputManager.</p></li>
<li><p>static_assert</p></li>
<li><p>variadic templates</p></li>
</ul>
</section>
<section id="other-c-11-features-that-will-not-be-useful">
<h3><a class="toc-backref" href="#id21">Other C++11 features that will not be useful</a><a class="headerlink" href="#other-c-11-features-that-will-not-be-useful" title="本標題的永久連結">¶</a></h3>
<ul class="simple">
<li><p>Threading support (Relies on C++ threading model; use Qt threading instead)</p></li>
<li><p>shared_ptr and weak_ptr (Relies on C++ threading model; use KisSharedPointer instead)</p></li>
<li><p>New literal types (already have QString/ki18n)</p></li>
<li><p>Extended Unions (already have QVariant)</p></li>
</ul>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="new_features.html" class="btn btn-neutral float-right" title="Developing Features" accesskey="n" rel="next"> <!-- 下一個 --> <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="krita_svg_extensions.html" class="btn btn-neutral" title="Krita SVG Extensions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> <!-- 上一個  -->  </a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版權所有 licensed under the GNU Free Documentation License 1.3+ unless stated otherwise。
      
        <span class="commit">
          修訂版本 <code>ec76001</code>
        </span>
      

    </p>
  </div>
  使用 <a href="http://sphinx-doc.org/">Sphinx</a> 以及經修改過的 <a href="https://github.com/rtfd/sphinx_rtd_theme">RTD 主題</a>建置<br/>
  <a href="https://krita.org" title="Krita 官方網站">Krita 官方網站</a> |
  <a href="https://invent.kde.org/documentation/docs-krita-org/" title="這份手冊的 KDE GitLab 專案網址">docs.krita.org 的 Git 原始碼儲存庫</a> |
  <a href="https://www.kde.org/community/whatiskde/impressum-en.php" title="了解更多關於 KDE、code of conduct（行為準則）、隱私政策及 GDPR（一般資料保護規則）">KDE Impressum</a>
   

</footer>

        </div>
      </div>

    </section>

  </div>
  

  
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
      <script src="../_static/jquery.js"></script>
      <script src="../_static/underscore.js"></script>
      <script src="../_static/doctools.js"></script>
      <script src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

 <script type="text/javascript">
	 var _paq=_paq||[];
	 _paq.push(['setCookieDomain','*.krita.org']);
	 _paq.push(['setDomains','*.krita.org']);
	 _paq.push(['setDocumentTitle',document.domain+"/"+document.title]);
	 _paq.push(['trackPageView']);
	 _paq.push(['enableLinkTracking']);

	 (function(){
	 	var u="//stats.kde.org/";
	    _paq.push(['setTrackerUrl',u+'piwik.php']);
	    _paq.push(['setSiteId',13]);
	    var d = document, g = d.createElement('script'),s=d.getElementsByTagName('script')[0];
	    g.type = 'text/javascript';
	    g.async = true;
	    g.defer = true;
	    g.src = u+'piwik.js';
	    s.parentNode.insertBefore(g,s);
	  })();
</script> 
<noscript><p><img src="//stats.kde.org/piwik.php?idsite=13" style="border:0;" alt="" /></p></noscript>

</body>
</html>